"""
Code Executor Service
Safely executes pandas code generated by LLM
"""

import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import io
import os
import re
import base64
import tempfile
from contextlib import redirect_stdout
from typing import Dict, Any, Optional, Tuple
import traceback
from datetime import datetime


def _sanitize_annotation_font(font: Any) -> Any:
    """Plotly layout.annotation.Font only supports color, family, size — not weight."""
    if font is None or not isinstance(font, dict):
        return font
    return {k: v for k, v in font.items() if k in ('color', 'family', 'size')}

class CodeExecutorService:
    # Forbidden patterns in user code (security / guardrails)
    FORBIDDEN_PATTERNS = [
        (r"subprocess\.", "subprocess calls"),
        (r"os\.system\s*\(", "os.system"),
        (r"eval\s*\(", "eval()"),
        (r"__import__\s*\(", "__import__"),
        (r"exec\s*\(", "exec() (use of exec in generated code)"),
        (r"requests\.(get|post|put|delete)\s*\(", "network requests"),
        (r"urllib\.request\.", "urllib network access"),
        (r"open\s*\(\s*['\"]\.\.", "open() outside current directory"),
        (r"open\s*\(\s*['\"][a-zA-Z]:\\\\", "open() with absolute path"),
    ]

    def validate_code(self, code: str, schema: Optional[Dict[str, Any]] = None) -> Tuple[bool, Optional[str]]:
        """Validate generated code: no forbidden patterns; optional column check. Returns (ok, error_message)."""
        if not code or not code.strip():
            return False, "Code is empty."
        for pattern, name in self.FORBIDDEN_PATTERNS:
            if re.search(pattern, code):
                return False, f"Forbidden: {name}."
        allowed_columns = set()
        if schema and isinstance(schema.get("columns"), list):
            allowed_columns = set(schema["columns"])
        if allowed_columns:
            # Columns assigned in code are allowed (e.g. df['year'] = ...)
            assigned = set(re.findall(r"df\s*\[\s*['\"]([^'\"]+)['\"]\s*\]\s*=", code))
            assigned |= set(re.findall(r'df\s*\.\s*(\w+)\s*=', code))
            allowed_columns = allowed_columns | assigned
            # Used: df['col'] and df["col"]; df.col only if col looks like a column (in schema)
            used = set(re.findall(r"df\s*\[\s*['\"]([^'\"]+)['\"]\s*\]", code))
            dot_used = set(re.findall(r"df\s*\.\s*(\w+)", code))
            used |= (dot_used & allowed_columns)  # only count df.xxx as column if xxx in schema
            bad = used - allowed_columns
            if bad:
                return False, f"Column(s) not in data: {sorted(bad)}. Use only: {sorted(allowed_columns)[:30]}."
        return True, None

    def extract_code(self, llm_response: str) -> str:
        """Extract Python code from LLM response"""
        # Look for code blocks with ```python
        pattern = r'```python\n(.*?)\n```'
        matches = re.findall(pattern, llm_response, re.DOTALL)
        
        if matches:
            return matches[0]
        
        # Try without 'python' tag
        pattern = r'```\n(.*?)\n```'
        matches = re.findall(pattern, llm_response, re.DOTALL)
        
        if matches:
            return matches[0]
        
        # If no code blocks found, create a simple print statement
        # This handles cases where LLM returns plain text
        cleaned_response = llm_response.replace('"', '\\"').replace('\n', '\\n')
        return f'print("{cleaned_response}")'

    def extract_key_takeaways(self, llm_response: str) -> Optional[str]:
        """Extract 'Key takeaways:' or 'Key takeaway:' block from the end of the LLM response (after the code block)."""
        if not llm_response or not llm_response.strip():
            return None
        # Look after the last closing code fence
        last_fence = llm_response.rfind("```")
        if last_fence == -1:
            tail = llm_response
        else:
            tail = llm_response[last_fence + 3:].strip()
        for prefix in ("Key takeaways:", "Key takeaway:"):
            idx = tail.find(prefix)
            if idx != -1:
                text = tail[idx:].strip()
                if len(text) > len(prefix) + 5:
                    return text
        return None
    
    def execute_safely(
        self,
        code: str,
        df: pd.DataFrame,
        df_pop: Optional[pd.DataFrame] = None,
        df_wdi: Optional[pd.DataFrame] = None,
    ) -> Dict[str, Any]:
        """Execute Python code in a safe environment"""
        # Prepare chart buffer
        chart_buffer = io.BytesIO()
        
        # Store original savefig
        original_savefig = plt.savefig
        
        def savefig_wrapper(*args, **kwargs):
            """Wrapper to capture matplotlib figures"""
            chart_buffer.seek(0)
            chart_buffer.truncate(0)
            
            # Remove filename if provided and skip it
            if args and isinstance(args[0], str):
                args = args[1:]
            
            # Set defaults only if not already provided
            if 'dpi' not in kwargs:
                kwargs['dpi'] = 150
            if 'bbox_inches' not in kwargs:
                kwargs['bbox_inches'] = 'tight'
            
            # Always save to buffer as PNG
            return original_savefig(chart_buffer, format='png', *args, **kwargs)
        
        # Override plt.savefig
        plt.savefig = savefig_wrapper

        # Patch Plotly: annotation Font only supports color, family, size — not weight
        _original_add_annotation = go.Figure.add_annotation
        def _safe_add_annotation(self: Any, *args: Any, **kwargs: Any) -> Any:
            if 'font' in kwargs:
                kwargs = dict(kwargs)
                kwargs['font'] = _sanitize_annotation_font(kwargs['font'])
            return _original_add_annotation(self, *args, **kwargs)
        go.Figure.add_annotation = _safe_add_annotation
        
        # Create safe execution environment
        safe_globals = {
            'pd': pd,
            'np': np,
            'plt': plt,
            'px': px,
            'go': go,
            'df': df,
            'df_pop': df_pop if df_pop is not None else pd.DataFrame(),
            'df_wdi': df_wdi if df_wdi is not None else pd.DataFrame(),
            'datetime': datetime,
            'print': print,
            'len': len,
            'str': str,
            'int': int,
            'float': float,
            'list': list,
            'dict': dict,
            'range': range,
            'enumerate': enumerate,
            'zip': zip,
            'sum': sum,
            'max': max,
            'min': min,
            'abs': abs,
            'round': round,
            'sorted': sorted,
            'set': set,
            'type': type,
            'isinstance': isinstance,
        }
        
        # Add optional libraries
        try:
            from sklearn.linear_model import LinearRegression
            from sklearn.metrics import r2_score, mean_squared_error
            safe_globals['LinearRegression'] = LinearRegression
            safe_globals['r2_score'] = r2_score
            safe_globals['mean_squared_error'] = mean_squared_error
        except ImportError:
            pass
        
        try:
            import statsmodels.api as sm
            safe_globals['sm'] = sm
        except ImportError:
            pass
        
        # Use same dict as globals and locals so top-level variables are visible inside
        # user-defined functions (e.g. state_keywords inside is_state_actor)
        safe_locals = safe_globals
        output = io.StringIO()
        # Use a writable directory for CSV/file output from executed code
        output_dir = os.path.join(tempfile.gettempdir(), 'fcv_analyst_output')
        os.makedirs(output_dir, exist_ok=True)
        original_cwd = os.getcwd()
        try:
            os.chdir(output_dir)
        except OSError:
            output_dir = tempfile.gettempdir()
            os.chdir(output_dir)
        
        try:
            # Ensure event_date is datetime before execution
            if 'event_date' in df.columns:
                df['event_date'] = pd.to_datetime(df['event_date'], errors='coerce')
            
            # Execute code with UTF-8 encoding support
            # Ensure code is properly encoded
            if isinstance(code, bytes):
                code = code.decode('utf-8', errors='replace')
            
            with redirect_stdout(output):
                exec(code, safe_globals, safe_locals)
            
            output_text = output.getvalue()
            
            # Restore original functions
            plt.savefig = original_savefig
            go.Figure.add_annotation = _original_add_annotation
            
            # Extract charts
            charts = []
            
            # Check matplotlib chart
            chart_buffer.seek(0)
            buffer_content = chart_buffer.getvalue()
            if buffer_content:
                # Convert to base64
                base64_image = base64.b64encode(buffer_content).decode('utf-8')
                charts.append({
                    'type': 'matplotlib',
                    'data': base64_image
                })
            else:
                # Try to get current figure
                try:
                    current_fig = plt.gcf()
                    if current_fig and len(current_fig.axes) > 0:
                        chart_buffer.seek(0)
                        chart_buffer.truncate(0)
                        current_fig.savefig(chart_buffer, format='png', dpi=150, bbox_inches='tight')
                        chart_buffer.seek(0)
                        buffer_content = chart_buffer.getvalue()
                        if buffer_content:
                            base64_image = base64.b64encode(buffer_content).decode('utf-8')
                            charts.append({
                                'type': 'matplotlib',
                                'data': base64_image
                            })
                except:
                    pass
            
            # Check for plotly figures
            plotly_fig = None
            for var_name in ['fig', 'figure', 'plot', 'chart']:
                if var_name in safe_locals:
                    var_value = safe_locals[var_name]
                    try:
                        type_str = str(type(var_value))
                        if 'plotly' in type_str.lower() and 'figure' in type_str.lower():
                            plotly_fig = var_value
                            break
                    except:
                        pass
            
            if plotly_fig:
                # Convert plotly figure to JSON
                try:
                    plotly_json = plotly_fig.to_json()
                    charts.append({
                        'type': 'plotly',
                        'data': plotly_json
                    })
                except:
                    pass
            
            # Extract summary data
            summary_data = self._extract_summary_data(output_text)
            
            # Close all matplotlib figures to free memory
            plt.close('all')
            
            return {
                'success': True,
                'output': output_text,
                'charts': charts,
                'summary_data': summary_data
            }
            
        except Exception as e:
            # Restore original functions
            plt.savefig = original_savefig
            go.Figure.add_annotation = _original_add_annotation
            plt.close('all')
            
            error_msg = str(e)
            tb = traceback.format_exc()
            
            return {
                'success': False,
                'output': None,
                'error': f"{error_msg}\n\nTraceback:\n{tb}",
                'charts': []
            }
        finally:
            try:
                go.Figure.add_annotation = _original_add_annotation
            except NameError:
                pass
            try:
                os.chdir(original_cwd)
            except OSError:
                pass
    
    def _extract_summary_data(self, output_text: str) -> Optional[Dict[str, Any]]:
        """Extract structured summary data from code output"""
        # Look for summary_data dictionary in output
        if 'summary_data' not in output_text:
            return None
        
        try:
            # Try to parse as JSON
            import json
            # Find JSON-like structure
            start_idx = output_text.find('{', output_text.find('summary_data'))
            if start_idx == -1:
                return None
            
            # Find matching closing brace
            brace_count = 0
            end_idx = start_idx
            for i in range(start_idx, len(output_text)):
                if output_text[i] == '{':
                    brace_count += 1
                elif output_text[i] == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        end_idx = i + 1
                        break
            
            if end_idx > start_idx:
                json_str = output_text[start_idx:end_idx]
                return json.loads(json_str)
        except:
            pass
        
        return None
